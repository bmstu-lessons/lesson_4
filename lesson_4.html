<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<style>
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote {
    margin: 0;
    padding: 0;
}
body {
    font-family: "Helvetica Neue", Helvetica, "Hiragino Sans GB", Arial, sans-serif;
    font-size: 13px;
    line-height: 18px;
    color: #737373;
    background-color: white;
    margin: 10px 13px 10px 13px;
}
table {
	margin: 10px 0 15px 0;
	border-collapse: collapse;
}
td,th {	
	border: 1px solid #ddd;
	padding: 3px 10px;
}
th {
	padding: 5px 10px;	
}

a {
    color: #0069d6;
}
a:hover {
    color: #0050a3;
    text-decoration: none;
}
a img {
    border: none;
}
p {
    margin-bottom: 9px;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    color: #404040;
    line-height: 36px;
}
h1 {
    margin-bottom: 18px;
    font-size: 30px;
}
h2 {
    font-size: 24px;
}
h3 {
    font-size: 18px;
}
h4 {
    font-size: 16px;
}
h5 {
    font-size: 14px;
}
h6 {
    font-size: 13px;
}
hr {
    margin: 0 0 19px;
    border: 0;
    border-bottom: 1px solid #ccc;
}
blockquote {
    padding: 13px 13px 21px 15px;
    margin-bottom: 18px;
    font-family:georgia,serif;
    font-style: italic;
}
blockquote:before {
    content:"\201C";
    font-size:40px;
    margin-left:-10px;
    font-family:georgia,serif;
    color:#eee;
}
blockquote p {
    font-size: 14px;
    font-weight: 300;
    line-height: 18px;
    margin-bottom: 0;
    font-style: italic;
}
code, pre {
    font-family: Monaco, Andale Mono, Courier New, monospace;
}
code {
    background-color: #fee9cc;
    color: rgba(0, 0, 0, 0.75);
    padding: 1px 3px;
    font-size: 12px;
    -webkit-border-radius: 3px;
    -moz-border-radius: 3px;
    border-radius: 3px;
}
pre {
    display: block;
    padding: 14px;
    margin: 0 0 18px;
    line-height: 16px;
    font-size: 11px;
    border: 1px solid #d9d9d9;
    white-space: pre-wrap;
    word-wrap: break-word;
}
pre code {
    background-color: #fff;
    color:#737373;
    font-size: 11px;
    padding: 0;
}
sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:10px auto;
    }
}
@media print {
	body,code,pre code,h1,h2,h3,h4,h5,h6 {
		color: black;
	}
	table, pre {
		page-break-inside: avoid;
	}
}
</style>
<title>Тест</title>

</head>
<body>
<h1>Тест</h1>

<ul>
<li>Перечислите регистры общего назначения</li>
<li>Перечислите сегментные регистры</li>
<li>Перечислите регистры управления</li>
<li>В какие режимы работы процессора можно перейти из реального?</li>
<li>Перечислите способы адресации</li>
</ul>


<h1>Основы программирования для DOS</h1>

<!--
Самая простая и распространенная операционная система для компьютеров, основанных на процессорах Intel, - DOS.
-->




<!--
Итак, чтобы программа выполнилась любой ОС, она должна быть скомпилирована в исполняемый файл. Основные два формата исполняемых файлов в DOS - СОМ и ЕХЕ. Файлы типа СОМ содержат только скомпилированный код без какой-либо дополнительной информации о программе. Весь код, данные и стек такой программы располагаются в одном сегменте и не могут превышать 64 Кб. Файлы типа ЕХЕ содержат заголовок, где описывается размер файла, требуемый объем памяти, список команд в программе, использующих абсолютные адреса, которые зависят от расположения программы в памяти, и т. д. ЕХЕ-файл может иметь любой размер.
-->




<!--
Традиционно первая программа для освоения нового языка программирования - программа, выводящая на экран текст Hello world!
-->


<pre><code>; ex_1.asm

            .model      tiny                
            .code               
            org         100h
start:      mov         ah, 9
            mov         dx, offset msg
            int         21h                 
            ret                         
msg         db          "HelloWorld!", 0Dh, 0Ah,'$'
            end 
</code></pre>

<!--
Каждая программа на языке ассемблера содержит кроме комманд процессора еще и специальные инструкции, указывающие самому ассемблеру, как организовывать различные секции программы, где располагаются данные, а где команды, позволяющие создавать макроопределения, выбирать тип используемого процессора, организовывать связи между процедурами и т.д.
-->


<h2>Структура программы</h2>

<!--
Программа на языке ассемблера сосотоит из строк, имеющих следующий вид:
-->


<pre><code>метка          ком/дир       операнды            ; комментарий
</code></pre>

<!--Причем все поля не обязательны-->




<!--Метка может быть любой комбинацией букв английского алфавита, цифр и символов '_', '$', '@', '?', но цифра не может быть первым символом метки. Так же стоит отметить, что по умолчанию ассемблер не чуствителен к регистру символов, однако данное поведение можно поменять, задав определенную опцию в командной строке ассемблера-->


<h3>Метка:</h3>

<ul>
<li><p style='color:green'>mylabel</p></li>
<li><p style='color:green'>label123</p></li>
<li><p style='color:green'>label_$@?</p></li>
<li><p style='color:red'>1label</p></li>
</ul>


<!--Во втором поле, поле команды, может располагаться команда процессора, которая транслируется в исполняемый код, или директива, которая не приводит к появлению нового кода, а управляет работой самого ассемблера.-->


<h3>Команды:</h3>

<pre><code>; ex_1.asm

            .model      tiny                
            .code               
            `org`       100h
start:      `mov`       ah, 9
            `mov`       dx, offset msg
            `int`       21h                 
            `ret`                           
msg         db          "HelloWorld!", 0Dh, 0Ah,'$'
            end     
</code></pre>

<h3>Директивы:</h3>

<pre><code>; ex_1.asm

            `.model`    tiny                
            `.code`                     
            org         100h
start:      mov         ah, 9
            mov         dx, offset message
            int         21h
            ret                         
msg         db          "HelloWorld!", 0Dh, 0Ah,'$'
            `end`   
</code></pre>

<!--В поле операндов располагаются требуемые командой или директивой операнды-->


<h3>Операнды:</h3>

<pre><code>; ex_1.asm
            .model      `tiny`                  
            .code                       
            org         `100h`
start:      mov         `ah, 9`
            mov         `dx, offset msg `
            int         `21h`                   
            ret                         
msg         db          `"HelloWorld!", 0Dh, 0Ah,'$'`
            end     
</code></pre>

<!--И наконец, в поле комментариев, начало которого отмечается символом ; пишутся коментарии.-->


<h2>Некоторые непривилегированные команды</h2>

<p><strong>MOV</strong></p>

<pre><code>__Синтаксис__
    MOV приемник,источник
__Машинный код__
    88 /r — MOV r/m8,r8
    89 /r — MOV r/m16,r16
    89 /r — MOV r/m32,r32
    8А /r — MOV r8,r/m8
    8В /r — MOV r16,r/m16
    8В /r — MOV r32,r/m32
    8C /r — MOV r/m16,Sreg**
    8E /r — MOV Sreg,r/m16
    А0 — MOV AL,moffs8*
    A1 — MOV AX,moffs16*
    A1 — MOV EAX,moffs32*
    A2 — MOV moffs8*,AL
    A3 — MOV moffs16*,AX
    A3 — MOV moffs32*,EAX
    B0+rb — MOV r8,imm8
    B8+rw — MOV r16,imm16
    B8+rd — MOV r32,imm32
    C6 /0 — MOV r/m8,imm8
    C7 /0 — MOV r/m16,imm16
    C7 /0 — MOV r/m32,imm32
__Описание__
    Копирование
__Действие__
    Копирование содержимого операнда источник в операнд приемник.
__Флаги__
    OF = ? SF = ? ZF = ? AF = ? PF = ? CF = ?
</code></pre>

<p><strong>RET</strong></p>

<pre><code>__Синтаксис__
    RET число
__Машинный код__
    СЗ — ret (близкий возврат)
    СВ — ret (дальний возврат)
    С2 i16 — ret i16 (близкий возврат с выталкиванием i16 байт из стека)
    СА i16 — ret i16 (дальний возврат с выталкиванием i16 байт из стека) 
__Описание__
    Возврат из процедуры.
__Действие__
    Передача управления по адресу, расположенному на вершине стека. Этот адрес обычно помещается в стек командой CALL, его значение соответствует команде, следующей за командой CALL. Необязательный операнд число определяет количество байтов стека, которые будут вытолкнуты после выталкивания адреса возврата. Команда RET используется для выполнения трех вариантов возврата управления:
    Близкий возврат — возврат управления вызывающей процедуре в пределах текущего сегмента кода (внутрисегментный возврат). При этом из вершины стека выталкивается значение в регистр EIP/IP. Регистр CS не изменяется. Процессор продолжает выполнение кода в том же сегменте, но по другому смещению.
    Дальний возврат — возврат управления вызывающей процедуре, расположенной в отличном от текущего сегменте кода (межсегментный возврат). При этом из вершины стека последовательно выталкиваются значения в регистры EIP/IP и CS. Процессор продолжает выполнение кода
в другом сегменте.
    Дальний возврат между уровнями привилегий — дальний возврат управления коду на уровне привилегий, отличном от текущего. Этот вид возврата может быть выполнен только в защищенном режиме. Его механизм подобен механизму дальнего возврата за исключением того, что процессор следит за уровнями привилегий и правами доступа к сегментам кода и стека, которым возвращается управление для определения возможности подобной передачи. Команда RET очищает регистры DS, ES, FS и GS, если они ссылаются на соответствующие сегменты, недоступные на новом уровне привилегий. Так как при межуровневом возврате управления производится переключение стека, то команда RET также производит загрузку этих регистров из стека.
__Флаги__
    Изменяются только при переключении задачи
</code></pre>

<p><strong>INT</strong></p>

<pre><code>__Синтаксис__
    INT номер_прерывания
__Машинный код__
    int 3
    int imm8
__Описание__
    вызов подпрограммы обслуживания прерывания с номером прерывания, заданным операндом команды.
__Действие__
    записать в стек регистр флагов eflags/flags и адрес возврата. При записи адреса возврата вначале записывается содержимое сегментного регистра cs, затем содержимое указателя команд eip/ip;
    сбросить в ноль флаги if и tf;
    передать управление на программу обработки прерывания с указанным номером.
__Флаги__
    IF = 0  TF = 0
__Примечания__
    int 3 — имеет свой индивидуальный код операции 0cch и занимает один байт. Это обстоятельство делает ее очень удобной для использования в различных программных отладчиках для установки точек прерывания путем подмены первого байта любой команды. Микропроцессор, встречая в последовательности команд команду с кодом операции 0cch, вызывает программу обработки прерывания с номером вектора 3, которая служит для связи с программным отладчиком.
</code></pre>

<h2>Некоторые директивы</h2>

<!--
Директива определения переменных указывают ассемблеру, что в со- ответствующем месте программы располагается переменная, устанавливают ее тип (байт, слово, вещественное число и т. д.), задают начальное значение и ставят в соответствие переменной метку, которая будет использоваться для обращения к этим данным.
-->


<p><strong>D</strong>*</p>

<pre><code>__Синтаксис__
    имя_переменной d* значение
__Описание__
    где, D* — одна из нижеприведенных псевдокоманд: DB - определить байт;
        DW - определить слово (2 байта);
        DD - определить двойное слово (4 байта);
        DF - определить 6 байт (адрес в формате 16-битный селектор: 32-битное сме- щение);
        DQ - определить учетверенное слово (8 байт);
        DT - определить 10 байт (80-битные типы данных, используемые FPU).

    Поле значения может содержать одно или несколько чисел, строк символов (взятых в одиночные или двойные кавычки), операторов ? и DUP, разделенных запятыми. Все установленные таким образом данные окажутся в выходном файле, а имя переменной будет соответствовать адресу первого из указанных Значений. 

__Пример__    
    text_string     db      'Hello world!'
    number          dw      7
    table           db      1,2,3,4,5,6,7,8,9,OAh,OBh,OCh,ODh,OEh,OFh
    float_number    dd      3.5e7
</code></pre>

<h2>Организация программы</h2>

<!--Каждая программа, написанная на любом языке программирования, состоит из одного или нескольких сегментов. Обычно область памяти, в которой находятся команды, называют сегментом кода, область памяти с данными - сегментом данных и область памяти, отведенную под стек, - сегментом стека. Разумеется, ассемблер позволяет изменять устройство программы как угодно - помещать данные в сегмент кода, разносить код на множество сегментов, помещать стек в один сегмент с данными или вообще использовать один сегмент для всего.-->


<p>Сегмент программы описывается директивами <code>SEGMENT</code> и <code>ENDS</code>:</p>

<pre><code>имя_сегмента segment readonly выравн. тип разряд 'класс'
    ...
имя_сегмента ends
</code></pre>

<ul>
<li><strong>Имя сегмента</strong> - метка, которая будет использоваться для получения сегментного адреса.</li>
<li><strong>READONLY</strong> - Если этот операнд присутствует, MASM выдаст сообщение об ошибке на все команды, выполняющие запись в данный сегмент. Другие ассемблеры этот операнд игнорируют.</li>
<li><p><strong>Выравнивание</strong> - Указывает ассемблеру и компоновщику, с какого адреса может начинаться сегмент.</p>

<ul>
<li><code>BYTE</code> - с любого адреса;</li>
<li><code>WORD</code> - с четного адреса;</li>
<li><code>DWORD</code> - с адреса, кратного 4;</li>
<li><code>PARA</code> - с адреса, кратного 16 (граница параграфа);</li>
<li><p><code>PAGE</code> - с адреса, кратного 256.</p>

<p>  По умолчанию используется выравнивание по границе параграфа.</p></li>
</ul>
</li>
<li><p><strong>Тип</strong> -  Выбирает один из возможных типов комбинирования сегментов:</p>

<ul>
<li>тип <code>PUBLIC</code> (иногда используется синоним MEMORY) означает, что все такие сегменты с одинаковым именем, но разными классами будут объединены в один;</li>
<li>тип <code>STACK</code> - то же самое, что и PUBLIC, но должен использоваться для сегментов стека, потому что при загрузке программы сегмент, полученный объединением всех сегментов типа STACK, будет использоваться как стек;</li>
<li>сегменты типа <code>COMMON</code> с одинаковым именем также объединяются в один, но не последовательно, а по одному и тому же адресу, следовательно, длина суммарного сегмента будет равна не сумме длин объединяемых сегментов, как в случае PUBLIC и STACK, а длине максимального. Таким способом иногда можно формировать оверлейные программы;</li>
<li>тип <code>AT</code> - выражение указывает, что сегмент должен располагаться по фиксированному абсолютному адресу в памяти. Результат выражения, использующегося в качестве операнда для AT, равен этому адресу, деленному на 16. Например: segment at 40h - сегмент, начинающийся по абсолютному адресу 0400h. Такие сегменты обычно содержат только метки, указывающие на области памяти, которые могут потребоваться программе;</li>
<li><code>PRIVATE</code> (значение по умолчанию) - сегмент такого типа не объединяется с другими сегментами.</li>
</ul>
</li>
<li><strong>Разрядность</strong> - этот операнд может принимать значения USE16 и USE32. Размер сегмента, описанного как USE16, не может превышать 64 Кб, и все команды и адреса в этом сегменте считаются 16-битными. В этих сегментах все равно можно применять команды, использующие 32-битные регистры или ссылающиеся на данные в 32-битных сегментах, но они будут использовать префикс изменения разрядности операнда или адреса и окажутся длиннее и медленнее. Сегменты USE32 могут занимать до 4 Гб, и все команды и адреса в них по умолчанию 32-битные. Если разрядность сегмента не указана, по умолчанию используется USE 16 при условии, что перед .MODEL не применялась директива задания допустимого набора команд .386 или старше.</li>
<li><strong>Класс сегмента</strong> - это любая метка, взятая в одинарные кавычки. Все сегменты с одинаковым классом, даже сегменты типа PRIVATE, будут расположены в исполняемом файле непосредственно друг за другом.</li>
</ul>


<!--Для обращения к любому сегменту следует сначала загрузить его сегментный адрес (или селектор в защищенном режиме) в какой-нибудь сегментный регистр.-->


<p>Если в программе определено много сегментов, удобно объединить несколько сегментов в группу, адресуемую с помощью одного сегментного регистра:</p>

<pre><code>имя_группы group имя_сегмента...
</code></pre>

<!--
Операнды этой директивы - список имен сегментов (или выражений, использующих оператор SEG), которые объединяются в группу.
-->


<p>Имя группы теперь можно применять вместо имен сегментов для получения сегментного адреса и для директивы <code>ASSUME</code>:</p>

<pre><code>assume регистр:связь,..
</code></pre>

<!--
Директива ASSUME указывает ассемблеру, с каким сегментом или группой сегментов связан тот или иной сегментный регистр. В качестве операнда «связь» могут использоваться имена сегментов, имена групп, выражения с оператором SEG или слово «NOTHING», означающее отмену действия предыдущей ASSUME для данного регистра. Эта директива не изменяет значений сегментных регистров, а только позволяет ассемблеру проверять допустимость ссылок и самостоятельно вставлять при необходимости префиксы переопределения сегментов.
Перечисленные директивы удобны для создания больших программ на ассемблере, состоящих из разнообразных модулей и содержащих множество сегментов. В повседневном программировании обычно используется ограниченный набор простых вариантов организации программы, известных как модели памяти.
-->


<h3>Модели памяти и упрощенные директивы определения сегментов</h3>

<p>Модели памяти задаются директивой <code>.MODEL</code></p>

<pre><code>.model  модель, язык, модификатор
</code></pre>

<ul>
<li><p><strong>модель</strong> - одно из следующих слов:</p>

<ul>
<li><p><code>TINY</code> - код, данные и стек размещаются в одном и том же сегменте размером до 64 Кб. Эта модель памяти чаще всего используется при написании на ассемблере небольших программ;</p></li>
<li><p><code>SMALL</code> - код размещается в одном сегменте, а данные и стек - в другрм (для их описания могут применяться разные сегменты, но объединенные в одну группу). Эту модель памяти также удобно использовать для создания программ на ассемблере;</p></li>
<li><p><code>COMPACT</code> - код размещается в одном сегменте, а для хранения данных могут использоваться несколько сегментов, так что для обращения к данным требуется указывать сегмент и смещение (данные дальнего типа);</p></li>
<li><p><code>MEDIUM</code> - код размещается в нескольких сегментах, а все данные - в одном, поэтому для доступа к данным используется только смещение, а вызовы подпрограмм применяют команды дальнего вызова процедуры;</p></li>
<li><p><code>LARGE</code> и <code>HUGE</code> — и код, и данные могут занимать несколько сегментов;</p></li>
<li><p><code>FLAT</code> - то же, что и TINY, но используются 32-битные сегменты, так что мак-
симальный размер сегмента, содержащего и данные, и код, и стек, - 4 Мб.</p></li>
</ul>
</li>
<li><p><strong>Язык</strong> - необязательный операнд, принимающий значения С, PASCAL, BASIC, FORTRAN, SYSCALL и STDCALL. Если он указан, подразумевается, что Процедуры рассчитаны на вызов из программ на соответствующем языке высокого уровня, следовательно, если указан язык С, все имена ассемблерных процедур, объявленных как PUBLIC, будут изменены так, чтобы начинаться с символа подчеркивания, как это принято в С.</p></li>
<li><p><strong>Модификатор</strong> - необязательный операнд, принимающий значения NEARSTACK (по умолчанию) или FARSTACK. Во втором случае сегмент стека не будет объединяться в одну группу с сегментами данных.</p></li>
</ul>


<!--После того как модель памяти установлена, вступают в силу упрощенные директивы определения сегментов, объединяющие действия директив SEGMENT и ASSUME, Кроме того, сегменты, объявленные упрощенными директивами, не требуется закрывать директивой ENDS - они закрываются автоматически, как только ассемблер обнаруживает новую директиву определения сегмента или конец программы.-->


<p>Упрощенные директивы определения сегментов:</p>

<pre><code>`.code`     ~= _ТЕХТ segment word public 'CODE' | name_TEXT segment word public 'CODE'
`.stack`    ~= STACK segment para public 'stack'
`.data`     ~= _DATA segment word public 'DATA'
`.data?`    ~= _BSS segment word public 'BSS'
`.const`    ~= CONST segment word public 'CONST'
`.fardata`  ~= имя_сегмента segment para private 'FAR_DATA'
`.fardata?` ~= имя_сегмента segment para private 'FAR_BSS'
</code></pre>

<h3>Конец программы</h3>

<pre><code>`end`   start_label
</code></pre>

<!--Этой директивой завершается любая программа на ассемблере. В роли необязательного операнда здесь выступает метка (или выражение), определяющая адрес, с которого начинается выполнение программы. Если программа состоит из нескольких модулей, только один файл может содержать начальный адрес, так же как в С только один файл может содержать функцию main().-->


<hr />

<h3>ex_1</h3>

<pre><code>; ex_1.asm

            .model      tiny                ; Модель памяти, используемая для СОМ.
            .code                           ; Начало сегмента кода.
            org         100h                ; Начальное значение счетчика - 100h.
start:      mov         ah, 9               ; Номер функции DOS - в АН.
            mov         dx, offset msg      ; Адрес строки - в DX.
            int         21h                 ; Вызов системной функции DOS.
            ret                             ; Завершение СОМ-программы.
msg         db          "HelloWorld!", 0Dh, 0Ah,'$' ; Строка для вывода.
            end         start               ; Конец программы.
</code></pre>

<!--
Первая строка определяет модель памяти TINY, в которой сегменты кода, дан- ных и стека объединены. Эта модель предназначена для создания файлов типа СОМ. Директива .CODE начинает сегмент кода, который в нашем случае также должен содержать и данные.
ORG lOOh устанавливает значение программного счетчика в lOOh, потому что
при загрузке СОМ-файла в память DOS занимает первые 256 байт (lOOh) блоком данных PSP и располагает код программы только после этого блока. Все программы, которые компилируются в файлы типа СОМ, должны начинаться с этой директивы.
Метка START располагается перед первой командой в программе и будет использоваться в директиве END, чтобы указать, с какой команды начинается программа. Команда MOV АН,9 помещает число 9 в регистр АН - номер функции DOS «вывод строки».
Команда MOV DX.OFFSET MESSAGE помещает в регистр DX смещение метки MESSAGE относительно начала сегмента данных, который в нашем случае совпадает с сегментом кода.
Команда INT 21h вызывает системную функцию DOS. Эта команда - основное средство взаимодействия программ с операционной системой. В нашем примере вызывается функция DOS номер 9 - вывести строку на экран. Эта функция выводит строку от начала, адрес которого задается в регистрах DS:DX, до первого встреченного символа $. При запуске СОМ-файла регистр DS автоматически загружается сегментным адресом программы, а регистр DX был подготовлен предыдущей командой.
Команда RET используется обычно для возвращения из процедуры. DOS вызывает СОМ-программы так, что команда RET корректно завершает программу.

-->


<pre><code>tasm ex_1.asm
tlink /t /x ex_1.obj
./ex_1.com
</code></pre>

<h3>ex_2</h3>

<pre><code>; ex_2.asm

            .model      small               ; Модель памяти, используемая для ЕХЕ.
            .stack      100h                ; Сегмент стека размеромв 256 байт.
            .code                       

start:      mov         ax, DGROUP          ; Сегментный адрес строки message
            mov         ds, ax              ; помещается в DS
            mov         dx, offset msg
            mov         ah, 9
            int         21h
            mov         ax, 4C00h
            int         21h                 ; Функция DOS "завершить программу".
            .data
￼￼￼￼￼msg          db          "HelloWorld!", 0Dh, 0Ah,'$' ; Строка для вывода.
            end         start               ; Конец программы.
</code></pre>

<!--В этом примере определяются три сегмента - сегмент стека директивой .STACK размером в 256 байт; сегмент кода, начинающийся с директивы .CODE; и сегмент данных, начинающийся с .DATA и включающий строку. При запуске ЕХЕ-программы регистр DS уже не содержит адреса сегмента со строкой message (он указывает на сегмент с блоком данных PSP), а для вызова используемой функции DOS этот регистр должен иметь сегментный адрес строки. Команда МОV AX, DGROUP загружает в АХ сегментный адрес группы сегментов данных DGROUP, a MOV DS,AX копирует его в DS.  И наконец, программы типа ЕХЕ должны завершаться системным вызовом DOS 4Ch: в регистр АН помещается значение 4Ch, в регистр AL - код возврата (в данном примере код возврата 0 и регистры АН и AL загружаются одной командой MOV AX, 4COOh), после чего вызывается прерывание 21h.-->


<pre><code>tasm ex_2.asm
tlink /x ex_2.obj
./ex_2.exe
</code></pre>

<h2>ПЗ</h2>

<p>Напишите программу, выводящую на экран все ASCII-символы, 16 строк по 16 символов в строке.
(loop, push, popб inc, test, jcc)</p>

<h2>ДЗ</h2>

<pre><code>Изучить команды:
    PUSH
    PUSHA
    PUSHAD
    РОРА
    РОРАD
    IN
    OUT
    CWD
    CDQ
    CBW
    CWDE
    MOVSX
    MOVZX
    XLAT
    XLATB
    LEA
    ADD
    ADC
    XADD
    SUB
    SBB
    MUL
    IMUL
    DIV
    IDIV
    INC
    DEC
    NEG
    СМР
    CMPXCHG
    CMPXCHG8B
    DAA
    DAS
    AAA
    AAS
    AAM
    AAD
    AND
    OR
    XOR
    NOT
    TEST
    SAR
    SAL
    SHR
    SHL
    SHRD
    SHLD
    ROR
    ROL
    RCR
    RCL
    BT
    BTS
    BTR
    BTC
    BSF
    BSR
    SETcc
    JMP
    Jcc
    LOOP
    CALL
</code></pre>

<script src="jquery.js"></script>


<script>

$('pre code').each(function() {
    var text = $(this).html();
     $(this).html(text.replace(new RegExp("\_\_([^\_]+)\_\_", "g"), "<b>$1</b>"));
});


$('pre code').each(function() {
    var text = $(this).html();
    $(this).html(text.replace(new RegExp("`([^`]+)`", "g"), "<span style='background-color: #FEE9CC'>$1</span>  "));
});


</script>



</body>
</html>